#nullable enable
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace Nebula.Generators
{
    /// <summary>
    /// Generates C# source code for the compiled protocol data.
    /// </summary>
    internal static class CodeEmitter
    {
        public static string Emit(ProtocolData data)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable disable");
            sb.AppendLine();
            sb.AppendLine("using System.Collections.Frozen;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Nebula.Serialization;");
            sb.AppendLine("using Nebula;");  // For WorldRunner, NetBuffer, and NetPeer (global using)
            sb.AppendLine();
            sb.AppendLine("namespace Nebula.Serialization");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Auto-generated protocol data for network serialization.");
            sb.AppendLine("    /// Use the Protocol helper class for convenient access methods.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class GeneratedProtocol");
            sb.AppendLine("    {");

            // Static methods (serializable types)
            EmitStaticMethods(sb, data);
            
            // Scene maps
            EmitScenesMap(sb, data);
            EmitScenesPack(sb, data);
            EmitSceneInterestMap(sb, data);
            
            // Static network node paths
            EmitStaticNetworkNodePathsMap(sb, data);
            EmitStaticNetworkNodePathsPack(sb, data);
            
            // Properties
            EmitPropertiesMap(sb, data);
            EmitPropertiesLookup(sb, data);
            EmitPropertiesByStaticChildId(sb, data);
            
            // Functions
            EmitFunctionsMap(sb, data);
            EmitFunctionsLookup(sb, data);
            
            // Serial type pack
            EmitSerialTypePack(sb, data);
            
            // Network serialization delegates (generated lambdas for reflection-free serialization)
            EmitDelegateTypes(sb);
            EmitDeserializersDictionary(sb, data);
            EmitSerializersDictionary(sb, data);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void EmitStaticMethods(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<int, StaticMethodInfo> StaticMethods =");
            sb.AppendLine("            new Dictionary<int, StaticMethodInfo>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.StaticMethods)
            {
                sb.AppendLine($"                [{kvp.Key}] = new StaticMethodInfo((StaticMethodType){kvp.Value.MethodType}, \"{Escape(kvp.Value.TypeFullName)}\"),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitScenesMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<byte, string> ScenesMap =");
            sb.AppendLine("            new Dictionary<byte, string>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.ScenesMap)
            {
                sb.AppendLine($"                [{kvp.Key}] = \"{Escape(kvp.Value)}\",");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitScenesPack(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, byte> ScenesPack =");
            sb.AppendLine("            new Dictionary<string, byte>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.ScenesPack)
            {
                sb.AppendLine($"                [\"{Escape(kvp.Key)}\"] = {kvp.Value},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitSceneInterestMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, ProtocolSceneInterest> SceneInterestMap =");
            sb.AppendLine("            new Dictionary<string, ProtocolSceneInterest>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.SceneInterestMap)
            {
                sb.AppendLine($"                [\"{Escape(kvp.Key)}\"] = new ProtocolSceneInterest({kvp.Value.InterestAny}L, {kvp.Value.InterestRequired}L),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitStaticNetworkNodePathsMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<byte, string>> StaticNetworkNodePathsMap =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<byte, string>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.StaticNetworkNodePathsMap)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<byte, string>");
                sb.AppendLine("                {");
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [{node.Key}] = \"{Escape(node.Value)}\",");
                }
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitStaticNetworkNodePathsPack(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<string, byte>> StaticNetworkNodePathsPack =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<string, byte>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.StaticNetworkNodePathsPack)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<string, byte>");
                sb.AppendLine("                {");
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [\"{Escape(node.Key)}\"] = {node.Value},");
                }
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitPropertiesMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetProperty>>> PropertiesMap =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetProperty>>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.PropertiesMap)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<string, FrozenDictionary<string, ProtocolNetProperty>>");
                sb.AppendLine("                {");
                
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [\"{Escape(node.Key)}\"] = new Dictionary<string, ProtocolNetProperty>");
                    sb.AppendLine("                    {");
                    
                    foreach (var prop in node.Value)
                    {
                        EmitProperty(sb, prop.Key, prop.Value, "                        ");
                    }
                    
                    sb.AppendLine("                    }.ToFrozenDictionary(),");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitPropertiesLookup(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<int, ProtocolNetProperty>> PropertiesLookup =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<int, ProtocolNetProperty>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.PropertiesLookup)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<int, ProtocolNetProperty>");
                sb.AppendLine("                {");
                
                foreach (var prop in scene.Value)
                {
                    EmitPropertyWithIntKey(sb, prop.Key, prop.Value, "                    ");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitPropertiesByStaticChildId(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<byte, FrozenDictionary<string, ProtocolNetProperty>>> PropertiesByStaticChildId =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<byte, FrozenDictionary<string, ProtocolNetProperty>>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.PropertiesByStaticChildId)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<byte, FrozenDictionary<string, ProtocolNetProperty>>");
                sb.AppendLine("                {");
                
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [{node.Key}] = new Dictionary<string, ProtocolNetProperty>");
                    sb.AppendLine("                    {");
                    
                    foreach (var prop in node.Value)
                    {
                        EmitProperty(sb, prop.Key, prop.Value, "                        ");
                    }
                    
                    sb.AppendLine("                    }.ToFrozenDictionary(),");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitProperty(StringBuilder sb, string key, PropertyData prop, string indent)
        {
            string variantType;
            string? subtype = null;
            if (prop.IsEnum)
            {
                variantType = "Int";
                subtype = "Enum";
            }
            else
            {
                variantType = MapTypeToVariant(prop.TypeFullName, out subtype);
            }
            var actualSubtype = prop.SubtypeIdentifier ?? subtype ?? "None";
            
            sb.AppendLine($"{indent}[\"{Escape(key)}\"] = new ProtocolNetProperty(");
            sb.AppendLine($"{indent}    \"{Escape(prop.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(prop.Name)}\",");
            sb.AppendLine($"{indent}    SerialVariantType.{variantType},");
            sb.AppendLine($"{indent}    new SerialMetadata(\"{Escape(actualSubtype)}\"),");
            sb.AppendLine($"{indent}    {prop.Index},");
            sb.AppendLine($"{indent}    {prop.LocalIndex},");
            sb.AppendLine($"{indent}    {prop.InterestMask}L,");
            sb.AppendLine($"{indent}    {prop.InterestRequired}L,");
            sb.AppendLine($"{indent}    {prop.ClassIndex},");
            sb.AppendLine($"{indent}    {prop.NotifyOnChange.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.Interpolate.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.InterpolateSpeed.ToString(CultureInfo.InvariantCulture)}f,");
            sb.AppendLine($"{indent}    {prop.Predicted.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.ChunkBudget},");
            sb.AppendLine($"{indent}    {prop.IsObjectProperty.ToString().ToLowerInvariant()}),");
        }

        private static void EmitPropertyWithIntKey(StringBuilder sb, int key, PropertyData prop, string indent)
        {
            string variantType;
            string? subtype = null;
            if (prop.IsEnum)
            {
                variantType = "Int";
                subtype = "Enum";
            }
            else
            {
                variantType = MapTypeToVariant(prop.TypeFullName, out subtype);
            }
            var actualSubtype = prop.SubtypeIdentifier ?? subtype ?? "None";
            
            sb.AppendLine($"{indent}[{key}] = new ProtocolNetProperty(");
            sb.AppendLine($"{indent}    \"{Escape(prop.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(prop.Name)}\",");
            sb.AppendLine($"{indent}    SerialVariantType.{variantType},");
            sb.AppendLine($"{indent}    new SerialMetadata(\"{Escape(actualSubtype)}\"),");
            sb.AppendLine($"{indent}    {prop.Index},");
            sb.AppendLine($"{indent}    {prop.LocalIndex},");
            sb.AppendLine($"{indent}    {prop.InterestMask}L,");
            sb.AppendLine($"{indent}    {prop.InterestRequired}L,");
            sb.AppendLine($"{indent}    {prop.ClassIndex},");
            sb.AppendLine($"{indent}    {prop.NotifyOnChange.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.Interpolate.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.InterpolateSpeed.ToString(CultureInfo.InvariantCulture)}f,");
            sb.AppendLine($"{indent}    {prop.Predicted.ToString().ToLowerInvariant()},");
            sb.AppendLine($"{indent}    {prop.ChunkBudget},");
            sb.AppendLine($"{indent}    {prop.IsObjectProperty.ToString().ToLowerInvariant()}),");
        }

        private static void EmitFunctionsMap(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetFunction>>> FunctionsMap =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<string, FrozenDictionary<string, ProtocolNetFunction>>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.FunctionsMap)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<string, FrozenDictionary<string, ProtocolNetFunction>>");
                sb.AppendLine("                {");
                
                foreach (var node in scene.Value)
                {
                    sb.AppendLine($"                    [\"{Escape(node.Key)}\"] = new Dictionary<string, ProtocolNetFunction>");
                    sb.AppendLine("                    {");
                    
                    foreach (var func in node.Value)
                    {
                        EmitFunction(sb, func.Key, func.Value, "                        ");
                    }
                    
                    sb.AppendLine("                    }.ToFrozenDictionary(),");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitFunctionsLookup(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, FrozenDictionary<int, ProtocolNetFunction>> FunctionsLookup =");
            sb.AppendLine("            new Dictionary<string, FrozenDictionary<int, ProtocolNetFunction>>");
            sb.AppendLine("            {");
            
            foreach (var scene in data.FunctionsLookup)
            {
                sb.AppendLine($"                [\"{Escape(scene.Key)}\"] = new Dictionary<int, ProtocolNetFunction>");
                sb.AppendLine("                {");
                
                foreach (var func in scene.Value)
                {
                    EmitFunctionWithIntKey(sb, func.Key, func.Value, "                    ");
                }
                
                sb.AppendLine("                }.ToFrozenDictionary(),");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        private static void EmitFunction(StringBuilder sb, string key, FunctionData func, string indent)
        {
            sb.AppendLine($"{indent}[\"{Escape(key)}\"] = new ProtocolNetFunction(");
            sb.AppendLine($"{indent}    \"{Escape(func.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(func.Name)}\",");
            sb.AppendLine($"{indent}    {func.Index},");
            EmitArgumentsArray(sb, func.Arguments, indent + "    ");
            sb.AppendLine($"{indent}    (NetworkSources){func.Sources}),");
        }

        private static void EmitFunctionWithIntKey(StringBuilder sb, int key, FunctionData func, string indent)
        {
            sb.AppendLine($"{indent}[{key}] = new ProtocolNetFunction(");
            sb.AppendLine($"{indent}    \"{Escape(func.NodePath)}\",");
            sb.AppendLine($"{indent}    \"{Escape(func.Name)}\",");
            sb.AppendLine($"{indent}    {func.Index},");
            EmitArgumentsArray(sb, func.Arguments, indent + "    ");
            sb.AppendLine($"{indent}    (NetworkSources){func.Sources}),");
        }

        private static void EmitArgumentsArray(StringBuilder sb, List<ArgumentData> args, string indent)
        {
            if (args.Count == 0)
            {
                sb.AppendLine($"{indent}System.Array.Empty<NetFunctionArgument>(),");
                return;
            }

            sb.AppendLine($"{indent}new NetFunctionArgument[]");
            sb.AppendLine($"{indent}{{");
            
            foreach (var arg in args)
            {
                var variantType = MapTypeToVariant(arg.TypeFullName, out var subtype);
                var actualSubtype = arg.SubtypeIdentifier ?? subtype ?? "None";
                sb.AppendLine($"{indent}    new NetFunctionArgument(SerialVariantType.{variantType}, new SerialMetadata(\"{Escape(actualSubtype)}\")),");
            }
            
            sb.AppendLine($"{indent}}},");
        }

        private static void EmitSerialTypePack(StringBuilder sb, ProtocolData data)
        {
            sb.AppendLine("        public static readonly FrozenDictionary<string, int> SerialTypePack =");
            sb.AppendLine("            new Dictionary<string, int>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.SerialTypePack)
            {
                sb.AppendLine($"                [\"{Escape(kvp.Key)}\"] = {kvp.Value},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
        }

        private static string MapTypeToVariant(string typeFullName, out string? subtype)
        {
            subtype = null;
            
            return typeFullName switch
            {
                "System.Boolean" or "bool" => "Bool",
                "System.Int16" or "short" => (subtype = "Short", "Int").Item2,
                "System.Int32" or "int" => (subtype = "Int", "Int").Item2,
                "System.Byte" or "byte" => (subtype = "Byte", "Int").Item2,
                "System.Int64" or "long" => "Int",
                "System.UInt64" or "ulong" => (subtype = "ULong", "Int").Item2,
                "System.Single" or "float" => "Float",
                "System.Double" or "double" => "Float",
                "System.String" or "string" => "String",
                "System.Byte[]" or "byte[]" => "PackedByteArray",
                "System.Int64[]" or "long[]" => "PackedInt64Array",
                "Godot.Vector2" => "Vector2",
                "Godot.Vector2I" => "Vector2I",
                "Godot.Vector3" => "Vector3",
                "Godot.Vector3I" => "Vector3I",
                "Godot.Vector4" => "Vector4",
                "Godot.Quaternion" => "Quaternion",
                "Godot.Color" => "Color",
                "Godot.Transform2D" => "Transform2D",
                "Godot.Transform3D" => "Transform3D",
                "Godot.Basis" => "Basis",
                "Godot.Rect2" => "Rect2",
                "Godot.Rect2I" => "Rect2I",
                "Godot.Aabb" => "Aabb",
                "Godot.Plane" => "Plane",
                "Godot.Projection" => "Projection",
                _ when typeFullName.StartsWith("Godot.") => "Object",
                _ when typeFullName.Contains("[]") => "Array",
                _ => "Object" // Custom types default to Object
            };
        }

        private static string Escape(string s)
        {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"");
        }

        /// <summary>
        /// Emits delegate type definitions for serialization/deserialization.
        /// </summary>
        private static void EmitDelegateTypes(StringBuilder sb)
        {
            sb.AppendLine();
            sb.AppendLine("        #region Delegate Types");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Delegate for reflection-free network deserialization.</summary>");
            sb.AppendLine("        public delegate object NetworkDeserializeFunc(WorldRunner world, NetPeer peer, NetBuffer buffer, object existing);");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Delegate for reflection-free network serialization. Returns true if data was written.</summary>");
            sb.AppendLine("        public delegate bool NetworkSerializeFunc(WorldRunner world, NetPeer peer, ref PropertyCache cache, NetBuffer buffer, int maxBytes);");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Delegate for peer acknowledgment callback on INetSerializable types.</summary>");
            sb.AppendLine("        public delegate void OnPeerAcknowledgeFunc(object obj, UUID peerId);");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Delegate for peer disconnect callback on INetSerializable types.</summary>");
            sb.AppendLine("        public delegate void OnPeerDisconnectedFunc(object obj, UUID peerId);");
            sb.AppendLine();
            sb.AppendLine("        #endregion");
            sb.AppendLine();
        }

        /// <summary>
        /// Generates the dictionary mapping class index to deserializer lambdas.
        /// </summary>
        private static void EmitDeserializersDictionary(StringBuilder sb, ProtocolData data)
        {
            // Collect concrete generic types (same as serializers)
            var concreteGenerics = CollectConcreteGenericTypes(data);
            
            sb.AppendLine("        public static readonly FrozenDictionary<int, NetworkDeserializeFunc> Deserializers =");
            sb.AppendLine("            new Dictionary<int, NetworkDeserializeFunc>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.StaticMethods)
            {
                // Only include types that have NetworkDeserialize (bit 1)
                if ((kvp.Value.MethodType & 2) == 0)
                    continue;
                
                var typeName = kvp.Value.TypeFullName;
                
                // Skip open generic types (they contain '<' and '>' with type parameters like T)
                if (IsOpenGenericType(typeName))
                    continue;
                
                if (kvp.Value.IsValueType)
                {
                    // Value types (INetValue<T>) don't take an existing parameter
                    sb.AppendLine($"                [{kvp.Key}] = (world, peer, buffer, existing) => {typeName}.NetworkDeserialize(world, peer, buffer),");
                }
                else
                {
                    // Reference types (INetSerializable<T>) take an existing parameter
                    sb.AppendLine($"                [{kvp.Key}] = (world, peer, buffer, existing) => {typeName}.NetworkDeserialize(world, peer, buffer, existing as {typeName}),");
                }
            }
            
            // Add concrete generic types (e.g., NetArray<Vector3>)
            foreach (var (classIndex, concreteType, isValueType) in concreteGenerics)
            {
                if (isValueType)
                {
                    sb.AppendLine($"                [{classIndex}] = (world, peer, buffer, existing) => {concreteType}.NetworkDeserialize(world, peer, buffer),");
                }
                else
                {
                    sb.AppendLine($"                [{classIndex}] = (world, peer, buffer, existing) => {concreteType}.NetworkDeserialize(world, peer, buffer, existing as {concreteType}),");
                }
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        /// <summary>
        /// Generates static serializer methods and the dictionary mapping class index to them.
        /// Uses static methods instead of lambdas to avoid C# version issues with ref parameters in lambdas.
        /// </summary>
        private static void EmitSerializersDictionary(StringBuilder sb, ProtocolData data)
        {
            // Collect concrete generic types from properties
            // These need serializers generated even though their open generic definitions are skipped
            var concreteGenerics = CollectConcreteGenericTypes(data);
            
            // First, emit all the static serializer methods
            sb.AppendLine("        #region Serializer Methods");
            sb.AppendLine();
            
            foreach (var kvp in data.StaticMethods)
            {
                // Only include types that have NetworkSerialize (bit 0)
                if ((kvp.Value.MethodType & 1) == 0)
                    continue;
                
                var typeName = kvp.Value.TypeFullName;
                
                // Skip open generic types - we'll handle concrete generic types separately
                if (IsOpenGenericType(typeName))
                    continue;
                
                var shortName = GetShortTypeName(typeName);
                var methodName = $"Serializer_{kvp.Key}";
                
                if (kvp.Value.IsValueType)
                {
                    // Value types (INetValue<T>) don't support maxBytes, always return true
                    sb.AppendLine($"        private static bool {methodName}(WorldRunner world, NetPeer peer, ref PropertyCache cache, NetBuffer buffer, int maxBytes)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            {typeName}.NetworkSerialize(world, peer, in cache.{shortName}Value, buffer);");
                    sb.AppendLine("            return true;");
                    sb.AppendLine("        }");
                }
                else
                {
                    // Reference types (INetSerializable<T>) support maxBytes and return bool
                    sb.AppendLine($"        private static bool {methodName}(WorldRunner world, NetPeer peer, ref PropertyCache cache, NetBuffer buffer, int maxBytes)");
                    sb.AppendLine($"            => {typeName}.NetworkSerialize(world, peer, ({typeName})cache.RefValue, buffer, maxBytes);");
                }
                sb.AppendLine();
            }
            
            // Emit serializers for concrete generic types (e.g., NetArray<Vector3>)
            foreach (var (classIndex, concreteType, isValueType) in concreteGenerics)
            {
                var methodName = $"Serializer_{classIndex}";
                
                if (isValueType)
                {
                    var shortName = GetShortTypeName(concreteType);
                    sb.AppendLine($"        private static bool {methodName}(WorldRunner world, NetPeer peer, ref PropertyCache cache, NetBuffer buffer, int maxBytes)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            {concreteType}.NetworkSerialize(world, peer, in cache.{shortName}Value, buffer);");
                    sb.AppendLine("            return true;");
                    sb.AppendLine("        }");
                }
                else
                {
                    sb.AppendLine($"        private static bool {methodName}(WorldRunner world, NetPeer peer, ref PropertyCache cache, NetBuffer buffer, int maxBytes)");
                    sb.AppendLine($"            => {concreteType}.NetworkSerialize(world, peer, ({concreteType})cache.RefValue, buffer, maxBytes);");
                }
                sb.AppendLine();
            }
            
            sb.AppendLine("        #endregion");
            sb.AppendLine();
            
            // Emit OnPeerAcknowledge methods for reference types
            sb.AppendLine("        #region OnPeerAcknowledge Methods");
            sb.AppendLine();
            
            foreach (var kvp in data.StaticMethods)
            {
                // Only for reference types (INetSerializable)
                if (kvp.Value.IsValueType)
                    continue;
                
                // Only include types that have NetworkSerialize (bit 0)
                if ((kvp.Value.MethodType & 1) == 0)
                    continue;
                
                var typeName = kvp.Value.TypeFullName;
                
                // Skip open generic types
                if (IsOpenGenericType(typeName))
                    continue;
                
                var methodName = $"OnPeerAcknowledge_{kvp.Key}";
                sb.AppendLine($"        private static void {methodName}(object obj, UUID peerId)");
                sb.AppendLine($"            => {typeName}.OnPeerAcknowledge(({typeName})obj, peerId);");
                sb.AppendLine();
            }
            
            // Emit OnPeerAcknowledge for concrete generic types (reference types only)
            foreach (var (classIndex, concreteType, isValueType) in concreteGenerics)
            {
                if (isValueType) continue;
                
                var methodName = $"OnPeerAcknowledge_{classIndex}";
                sb.AppendLine($"        private static void {methodName}(object obj, UUID peerId)");
                sb.AppendLine($"            => {concreteType}.OnPeerAcknowledge(({concreteType})obj, peerId);");
                sb.AppendLine();
            }
            
            sb.AppendLine("        #endregion");
            sb.AppendLine();
            
            // Emit OnPeerDisconnected methods for reference types
            sb.AppendLine("        #region OnPeerDisconnected Methods");
            sb.AppendLine();
            
            foreach (var kvp in data.StaticMethods)
            {
                // Only for reference types (INetSerializable)
                if (kvp.Value.IsValueType)
                    continue;
                
                // Only include types that have NetworkSerialize (bit 0)
                if ((kvp.Value.MethodType & 1) == 0)
                    continue;
                
                var typeName = kvp.Value.TypeFullName;
                
                // Skip open generic types
                if (IsOpenGenericType(typeName))
                    continue;
                
                var methodName = $"OnPeerDisconnected_{kvp.Key}";
                sb.AppendLine($"        private static void {methodName}(object obj, UUID peerId)");
                sb.AppendLine($"            => {typeName}.OnPeerDisconnected(({typeName})obj, peerId);");
                sb.AppendLine();
            }
            
            // Emit OnPeerDisconnected for concrete generic types (reference types only)
            foreach (var (classIndex, concreteType, isValueType) in concreteGenerics)
            {
                if (isValueType) continue;
                
                var methodName = $"OnPeerDisconnected_{classIndex}";
                sb.AppendLine($"        private static void {methodName}(object obj, UUID peerId)");
                sb.AppendLine($"            => {concreteType}.OnPeerDisconnected(({concreteType})obj, peerId);");
                sb.AppendLine();
            }
            
            sb.AppendLine("        #endregion");
            sb.AppendLine();
            
            // Now emit the dictionary using method group references
            sb.AppendLine("        public static readonly FrozenDictionary<int, NetworkSerializeFunc> Serializers =");
            sb.AppendLine("            new Dictionary<int, NetworkSerializeFunc>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.StaticMethods)
            {
                // Only include types that have NetworkSerialize (bit 0)
                if ((kvp.Value.MethodType & 1) == 0)
                    continue;
                
                var typeName = kvp.Value.TypeFullName;
                
                // Skip open generic types
                if (IsOpenGenericType(typeName))
                    continue;
                
                sb.AppendLine($"                [{kvp.Key}] = Serializer_{kvp.Key},");
            }
            
            // Include concrete generic types in the dictionary
            foreach (var (classIndex, _, _) in concreteGenerics)
            {
                sb.AppendLine($"                [{classIndex}] = Serializer_{classIndex},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
            
            // Emit OnPeerAcknowledge dictionary (only reference types)
            sb.AppendLine("        public static readonly FrozenDictionary<int, OnPeerAcknowledgeFunc> OnPeerAcknowledgeFuncs =");
            sb.AppendLine("            new Dictionary<int, OnPeerAcknowledgeFunc>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.StaticMethods)
            {
                if (kvp.Value.IsValueType)
                    continue;
                if ((kvp.Value.MethodType & 1) == 0)
                    continue;
                var typeName = kvp.Value.TypeFullName;
                if (IsOpenGenericType(typeName))
                    continue;
                
                sb.AppendLine($"                [{kvp.Key}] = OnPeerAcknowledge_{kvp.Key},");
            }
            
            // Include concrete generic reference types
            foreach (var (classIndex, _, isValueType) in concreteGenerics)
            {
                if (!isValueType)
                    sb.AppendLine($"                [{classIndex}] = OnPeerAcknowledge_{classIndex},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
            
            // Emit OnPeerDisconnected dictionary (only reference types)
            sb.AppendLine("        public static readonly FrozenDictionary<int, OnPeerDisconnectedFunc> OnPeerDisconnectedFuncs =");
            sb.AppendLine("            new Dictionary<int, OnPeerDisconnectedFunc>");
            sb.AppendLine("            {");
            
            foreach (var kvp in data.StaticMethods)
            {
                if (kvp.Value.IsValueType)
                    continue;
                if ((kvp.Value.MethodType & 1) == 0)
                    continue;
                var typeName = kvp.Value.TypeFullName;
                if (IsOpenGenericType(typeName))
                    continue;
                
                sb.AppendLine($"                [{kvp.Key}] = OnPeerDisconnected_{kvp.Key},");
            }
            
            // Include concrete generic reference types
            foreach (var (classIndex, _, isValueType) in concreteGenerics)
            {
                if (!isValueType)
                    sb.AppendLine($"                [{classIndex}] = OnPeerDisconnected_{classIndex},");
            }
            
            sb.AppendLine("            }.ToFrozenDictionary();");
            sb.AppendLine();
        }

        /// <summary>
        /// Gets the short type name (without namespace) for PropertyCache field names.
        /// e.g., "Nebula.NetId" -> "NetId"
        /// </summary>
        private static string GetShortTypeName(string fullTypeName)
        {
            var lastDot = fullTypeName.LastIndexOf('.');
            return lastDot >= 0 ? fullTypeName.Substring(lastDot + 1) : fullTypeName;
        }

        /// <summary>
        /// Checks if a type name represents an open generic type (e.g., "LazyPeerState&lt;T&gt;").
        /// Open generic types cannot be used directly in generated code.
        /// </summary>
        private static bool IsOpenGenericType(string typeName)
        {
            // Check if the type has generic parameters
            var genericStart = typeName.IndexOf('<');
            if (genericStart < 0)
                return false;
            
            var genericEnd = typeName.LastIndexOf('>');
            if (genericEnd < 0)
                return false;
            
            // Extract the generic arguments
            var genericArgs = typeName.Substring(genericStart + 1, genericEnd - genericStart - 1);
            
            // If the generic arguments are single letters (T, U, V, etc.) or contain commas with single letters,
            // it's likely an open generic type
            var args = genericArgs.Split(',');
            foreach (var arg in args)
            {
                var trimmed = arg.Trim();
                // Single letter type parameters like T, U, V, TValue, TKey, etc.
                if (trimmed.Length == 1 && char.IsUpper(trimmed[0]))
                    return true;
                // Common generic parameter naming patterns
                if (trimmed.StartsWith("T") && (trimmed.Length == 1 || char.IsUpper(trimmed[1])))
                    return true;
            }
            
            return false;
        }
        
        /// <summary>
        /// Collects concrete generic types used in properties that need serializers generated.
        /// For example, if a property uses NetArray&lt;Vector3&gt;, we need to generate a serializer for it
        /// even though the open generic NetArray&lt;T&gt; is registered in StaticMethods.
        /// </summary>
        private static List<(int classIndex, string concreteType, bool isValueType)> CollectConcreteGenericTypes(ProtocolData data)
        {
            var result = new List<(int, string, bool)>();
            var seen = new HashSet<int>();
            
            // Find all open generic types with their class indices
            var openGenericIndices = new Dictionary<string, (int index, bool isValueType)>();
            foreach (var kvp in data.StaticMethods)
            {
                var typeName = kvp.Value.TypeFullName;
                if (IsOpenGenericType(typeName))
                {
                    // Extract the base name (e.g., "Nebula.Serialization.NetArray" from "Nebula.Serialization.NetArray<T>")
                    var genericStart = typeName.IndexOf('<');
                    if (genericStart > 0)
                    {
                        var baseName = typeName.Substring(0, genericStart);
                        openGenericIndices[baseName] = (kvp.Key, kvp.Value.IsValueType);
                    }
                }
            }
            
            // Scan PropertiesLookup: scenePath -> propertyIndex -> PropertyData
            foreach (var sceneKvp in data.PropertiesLookup)
            {
                foreach (var propKvp in sceneKvp.Value)
                {
                    var prop = propKvp.Value;
                    ScanPropertyForConcreteGeneric(prop, openGenericIndices, seen, result);
                }
            }
            
            return result;
        }
        
        private static void ScanPropertyForConcreteGeneric(
            PropertyData prop,
            Dictionary<string, (int index, bool isValueType)> openGenericIndices,
            HashSet<int> seen,
            List<(int classIndex, string concreteType, bool isValueType)> result)
        {
            var typeName = prop.TypeFullName;
            
            // Skip if not a generic type or if it's an open generic
            if (string.IsNullOrEmpty(typeName) || typeName.IndexOf('<') < 0 || IsOpenGenericType(typeName))
                return;
            
            // Extract base name
            var genericStart = typeName.IndexOf('<');
            var baseName = typeName.Substring(0, genericStart);
            
            // Check if this is a concrete version of a known open generic
            if (openGenericIndices.TryGetValue(baseName, out var info))
            {
                if (!seen.Contains(info.index))
                {
                    seen.Add(info.index);
                    result.Add((info.index, typeName, info.isValueType));
                }
            }
        }
    }
}