using System;
using System.ComponentModel;
using Godot;
using Nebula.Serialization;
using Nebula.Serialization.Serializers;
using MongoDB.Bson;
using System.Threading.Tasks;
using Nebula.Utility;
using MongoDB.Bson.Serialization;
using Nebula.Utility.Tools;

namespace Nebula
{
    /**
		<summary>
		<see cref="Node3D">Node3D</see>, extended with Nebula networking capabilities. This is the most basic networked 3D object.
		See <see cref="NetNode"/> for more information.
		</summary>
	*/
    [Icon("res://addons/Nebula/Core/NetNode3D.png")]
    public partial class NetNode3D : Node3D, INetNode<NetNode3D>, INotifyPropertyChanged
    {
        public NetworkController Network { get; internal set; }
        public NetNode3D()
        {
            // Skip network initialization in editor to avoid errors during C# recompilation
            if (!Engine.IsEditorHint())
            {
                Network = new NetworkController(this);
            }
        }
        // Cannot have more than 8 serializers
        public IStateSerializer[] Serializers { get; private set; } = [];

        public override void _Notification(int what)
        {
            if (Engine.IsEditorHint()) return;
            if (what == NotificationSceneInstantiated)
            {
                Network.Setup();
            }
        }

        public virtual long InitializeInterest(NetPeer peer)
        {
            // By default, the peer has full interest in the node.
            return long.MaxValue;
        }

        public void SetupSerializers()
        {
            var spawnSerializer = new SpawnSerializer(Network);
            var propertySerializer = new NetPropertiesSerializer(Network);
            var interestResyncSerializer = new InterestResyncSerializer(Network);
            Serializers = [spawnSerializer, propertySerializer, interestResyncSerializer];
        }

        public virtual void _WorldReady() { }
        public virtual void _NetworkProcess(int _tick) { }
        public virtual void _Despawn() { }

        /// <summary>
        /// Processes interpolation for all interpolated properties.
        /// Override is generated by the source generator for classes with [NetProperty(Interpolate = true)].
        /// </summary>
        /// <param name="delta">Frame delta time in seconds</param>
        internal virtual void ProcessInterpolation(float delta) { }

        /// <summary>
        /// Stores current predicted state for rollback comparison.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual void StorePredictedState(int tick) { }

        /// <summary>
        /// Stores confirmed server state for reconciliation.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual void StoreConfirmedState() { }

        /// <summary>
        /// Compares predicted state with confirmed server state and restores mispredicted properties.
        /// Returns true if any misprediction was detected (rollback needed), false if all predictions correct.
        /// If forceRestoreAll is true, skips comparison and restores all properties to confirmed state.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual bool Reconcile(int tick, bool forceRestoreAll = false) => false;

        /// <summary>
        /// Restores properties from the prediction buffer for a given tick.
        /// Used when prediction was correct and we need to continue with predicted values after server state import.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual void RestoreToPredictedState(int tick) { }

        #region Explicit Interface Implementations
        // These delegate to the internal virtual methods to enable proper polymorphic dispatch
        // when called through the INetNodeBase interface. Without these, the interface's default
        // implementations would be called instead of the overridden methods in derived classes.
        
        void INetNodeBase.StorePredictedState(int tick) => StorePredictedState(tick);
        void INetNodeBase.StoreConfirmedState() => StoreConfirmedState();
        bool INetNodeBase.Reconcile(int tick, bool forceRestoreAll) => Reconcile(tick, forceRestoreAll);
        void INetNodeBase.RestoreToPredictedState(int tick) => RestoreToPredictedState(tick);
        #endregion

        /// <summary>
        /// Sets a network property by its class-local index.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        /// <param name="propIndex">The class-local property index</param>
        /// <param name="value">The new value from the network</param>
        internal virtual void SetNetPropertyByIndex(int propIndex, ref PropertyCache value) { }

        /// <summary>
        /// Invokes property change handlers for properties with NotifyOnChange = true.
        /// Override is generated by the source generator.
        /// </summary>
        internal virtual void InvokePropertyChangeHandler(int propIndex, int tick, ref PropertyCache oldVal, ref PropertyCache newVal) { }

        /// <summary>
        /// Initializes network property bindings for INetPropertyBindable properties (like NetArray).
        /// Called from _NetworkPrepare to bind callbacks for properties initialized inline.
        /// Override is generated by the source generator for classes with INetPropertyBindable properties.
        /// </summary>
        internal virtual void InitializeNetPropertyBindings() { }

        /// <summary>
        /// Writes all [NetProperty] values to a BSON document.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        internal virtual void WriteBsonProperties(BsonDocument doc, NetBsonContext context = default) { }

        /// <summary>
        /// Reads [NetProperty] values from a BSON document.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        internal virtual void ReadBsonProperties(BsonDocument doc) { }

        /// <inheritdoc/>
        public override void _Process(double delta)
        {
            if (Engine.IsEditorHint()) return;
            base._Process(delta);
            // Process interpolation on clients only
            // Note: Don't iterate StaticNetworkChildren here - Godot calls _Process on each node,
            // so each node handles its own interpolation. Manual iteration causes double-processing.
            if (!Network.IsServer)
            {
                ProcessInterpolation((float)delta);
            }
        }

        /// <inheritdoc/>
        public override void _PhysicsProcess(double delta) { }

        public static bool NetworkSerialize(WorldRunner currentWorld, NetPeer peer, NetNode3D obj, NetBuffer buffer, int maxBytes)
        {
            // maxBytes is ignored - NetNode3D serialization is always small (node reference)
            if (obj == null)
            {
                NetWriter.WriteUInt16(buffer, 0);
                return true;
            }
            NetId targetNetId;
            byte staticChildId = 0;
            if (obj.Network.IsNetScene())
            {
                targetNetId = obj.Network.NetId;
            }
            else
            {
                if (Protocol.PackNode(obj.Network.NetSceneFilePath, obj.Network.NetParent.RawNode.GetPathTo(obj), out staticChildId))
                {
                    targetNetId = obj.Network.NetParent.NetId;
                }
                else
                {
                    throw new Exception($"Failed to pack node: {obj.Network.NetSceneFilePath} cannot find static child {obj.Network.NetParent.RawNode.GetPathTo(obj)}: {obj.GetPath()}");
                }
            }
            var peerNodeId = currentWorld.GetPeerWorldState(peer).Value.WorldToPeerNodeMap[targetNetId];
            NetWriter.WriteUInt16(buffer, peerNodeId);
            NetWriter.WriteByte(buffer, staticChildId);
            return true;
        }

        public static void OnPeerAcknowledge(NetNode3D obj, UUID peerId)
        {
            // No-op: NetNode3D doesn't track per-peer state
        }

        public static void OnPeerDisconnected(NetNode3D obj, UUID peerId)
        {
            // No-op: NetNode3D doesn't track per-peer state
        }

        public static NetNode3D NetworkDeserialize(WorldRunner currentWorld, NetPeer peer, NetBuffer buffer, NetNode3D existing = null)
        {
            // Note: existing parameter ignored - NetNode3D deserialization is a lookup, not a create/update
            var networkID = NetReader.ReadUInt16(buffer);
            if (networkID == 0)
            {
                return null;
            }
            var staticChildId = NetReader.ReadByte(buffer);
            var node = currentWorld.GetNodeFromNetId(networkID)?.RawNode as NetNode3D;
            if (node == null)
            {
                return null;
            }
            if (staticChildId > 0)
            {
                node = node.GetNodeOrNull(Protocol.UnpackNode(node.SceneFilePath, staticChildId)) as NetNode3D;
            }
            return node;
        }

        public virtual BsonValue BsonSerialize(NetBsonContext context)
        {
            return NetNodeCommon.ToBSONDocument(this, context);
        }

        /// <summary>
        /// Virtual method called during BSON deserialization. Override in derived classes
        /// to add custom deserialization logic. Always call base.OnBsonDeserialize() first.
        /// </summary>
        public virtual async Task OnBsonDeserialize(NetBsonContext context, BsonDocument doc)
        {
            // Base implementation - no custom logic needed for NetNode3D
            // Derived classes should override this method
            await Task.CompletedTask;
        }

        public async Task<NetNode3D> BsonDeserialize(NetBsonContext context, byte[] bson)
        {
            return await BsonDeserialize(context, bson, this);
        }

        public static async Task<NetNode3D> BsonDeserialize(NetBsonContext context, byte[] bson, NetNode3D obj)
        {
            var doc = BsonSerializer.Deserialize<BsonDocument>(bson);

            if (doc == NetNodeCommon.NullBsonDocument)
            {
                return null;
            }

            // Perform base BSON deserialization (NetNodeCommon handles natural instantiation)
            var newNode = await NetNodeCommon.FromBSON(context, doc, obj);

            // Call the virtual method for custom deserialization logic
            await newNode.OnBsonDeserialize(context, doc);

            return newNode;
        }

        public string NodePathFromNetScene()
        {
            if (Network.IsNetScene())
            {
                return GetPathTo(this);
            }

            return Network.NetParent.RawNode.GetPathTo(this);
        }
    }
}
