using Nebula.Serialization;
using Nebula.Serialization.Serializers;

namespace Nebula {
    /// <summary>
    /// This provides a common interface for NetNode, NetNode2D, and NetNode3D.
    /// This is necessary because they don't share an inheritance chain.
    /// For example, NetNode2D inherits from Node2D, while NetNode ineherits from Node.
    /// NetNode2D cannot inherit from NetNode because it needs Node2D functionality and C# does not support multiple inheritance.
    /// </summary>
    public interface INetNodeBase {
        public NetworkController Network { get; }
        public IStateSerializer[] Serializers { get; }
        public void SetupSerializers();

        /// <summary>
        /// When the node is first spawned, and when players first connect to the world, this method is called to determine the initial interest layers for the node.
        /// </summary>
        /// <returns>The initial interest layers for the node.</returns>
        public long InitializeInterest(NetPeer peer);
        
        /// <summary>
        /// Called once when the world is ready for this node.
        /// </summary>
        public void _WorldReady() { }
        
        /// <summary>
        /// Called each network tick. Override to handle per-tick game logic.
        /// </summary>
        /// <param name="tick">The current network tick</param>
        public void _NetworkProcess(int tick) { }
        
        /// <summary>
        /// Called when this node is being despawned from the network.
        /// Override to perform cleanup before the node is removed.
        /// </summary>
        public void _Despawn() { }

        /// <summary>
        /// Invokes the property change handler for the given property index.
        /// This method is generated by the source generator for classes with [NetProperty(NotifyOnChange = true)].
        /// Default implementation does nothing - override is generated when properties have NotifyOnChange = true.
        /// </summary>
        /// <param name="propIndex">The index of the property (from GetNetPropertyIndex)</param>
        /// <param name="tick">The network tick when the change occurred</param>
        /// <param name="oldVal">The previous value stored in a PropertyCache</param>
        /// <param name="newVal">The new value stored in a PropertyCache</param>
        public void InvokePropertyChangeHandler(int propIndex, int tick, ref PropertyCache oldVal, ref PropertyCache newVal) { }

        /// <summary>
        /// Sets a network property by its index using the value from a PropertyCache.
        /// This method is generated by the source generator to avoid Godot boundary crossing.
        /// Default implementation does nothing - override is generated for all net properties.
        /// </summary>
        /// <param name="propIndex">The index of the property</param>
        /// <param name="value">The new value stored in a PropertyCache</param>
        public void SetNetPropertyByIndex(int propIndex, ref PropertyCache value) { }

        /// <summary>
        /// Initializes network property bindings for INetPropertyBindable properties (like NetArray).
        /// Called from _NetworkPrepare to bind mutation callbacks for properties initialized inline.
        /// Override is generated by the source generator for classes with INetPropertyBindable properties.
        /// </summary>
        public void InitializeNetPropertyBindings() { }

        /// <summary>
        /// Processes interpolation for all interpolated properties.
        /// Called each frame by the serializer on clients.
        /// This method is generated by the source generator for classes with [NetProperty(Interpolate = true)].
        /// </summary>
        /// <param name="delta">Frame delta time in seconds</param>
        public void ProcessInterpolation(float delta) { }

        #region Client-Side Prediction

        /// <summary>
        /// Stores current predicted state for rollback comparison.
        /// Generated implementation stores each [NetProperty(Predicted=true)] property
        /// in a circular buffer indexed by tick.
        /// </summary>
        /// <param name="tick">The tick to associate with this predicted state</param>
        public void StorePredictedState(int tick) { }

        /// <summary>
        /// Stores confirmed server state for reconciliation.
        /// Called when authoritative server state is received.
        /// </summary>
        public void StoreConfirmedState() { }

        /// <summary>
        /// Compares predicted state with confirmed server state and restores mispredicted properties.
        /// Combines comparison and selective restoration in a single call.
        /// If forceRestoreAll is true, skips comparison and restores all properties to confirmed state.
        /// </summary>
        /// <param name="tick">The tick whose predicted state to compare</param>
        /// <param name="forceRestoreAll">If true, restores all properties without comparing</param>
        /// <returns>True if any misprediction was detected (rollback needed), false if all predictions correct</returns>
        public bool Reconcile(int tick, bool forceRestoreAll = false) => false;

        /// <summary>
        /// Restores properties from the prediction buffer for a given tick.
        /// Used when prediction was correct and we need to continue with predicted values after server state import.
        /// </summary>
        public void RestoreToPredictedState(int tick) { }

        #endregion
    }

    public interface INetNode<T> : INetNodeBase, INetSerializable<T>, IBsonSerializable<T> where T : Godot.Node { }
}