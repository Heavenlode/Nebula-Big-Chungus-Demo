using System;
using System.ComponentModel;
using Godot;
using Nebula.Serialization;
using Nebula.Serialization.Serializers;
using MongoDB.Bson;
using System.Threading.Tasks;

namespace Nebula
{
    /**
		<summary>
		<see cref="Node2D">Node2D</see>, extended with Nebula networking capabilities. This is the most basic networked 2D object.
		See <see cref="NetNode"/> for more information.
		</summary>
	*/
    [Icon("res://addons/Nebula/Core/NetNode2D.png")]
    public partial class NetNode2D : Node2D, INetNode<NetNode2D>, INotifyPropertyChanged
    {
        public NetworkController Network { get; internal set; }
        public NetNode2D()
        {
            Network = new NetworkController(this);
        }
        // Cannot have more than 8 serializers
        public IStateSerializer[] Serializers { get; private set; } = [];

        public override void _Notification(int what)
        {
            if (what == NotificationSceneInstantiated)
            {
                Network.Setup();
            }
        }

        public virtual long InitializeInterest(NetPeer peer)
        {
            // By default, the peer has full interest in the node.
            return long.MaxValue;
        }

        public void SetupSerializers()
        {
            var spawnSerializer = new SpawnSerializer(Network);
            var propertySerializer = new NetPropertiesSerializer(Network);
            var interestResyncSerializer = new InterestResyncSerializer(Network);
            Serializers = [spawnSerializer, propertySerializer, interestResyncSerializer];
        }

        public virtual void _WorldReady() { }
        public virtual void _NetworkProcess(int _tick) { }
        public virtual void _Despawn() { }

        /// <summary>
        /// Processes interpolation for all interpolated properties.
        /// Override is generated by the source generator for classes with [NetProperty(Interpolate = true)].
        /// </summary>
        /// <param name="delta">Frame delta time in seconds</param>
        internal virtual void ProcessInterpolation(float delta) { }

        /// <summary>
        /// Stores current predicted state for rollback comparison.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual void StorePredictedState(int tick) { }

        /// <summary>
        /// Stores confirmed server state for reconciliation.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual void StoreConfirmedState() { }

        /// <summary>
        /// Compares predicted state with confirmed server state and restores mispredicted properties.
        /// Returns true if any misprediction was detected (rollback needed), false if all predictions correct.
        /// If forceRestoreAll is true, skips comparison and restores all properties to confirmed state.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual bool Reconcile(int tick, bool forceRestoreAll = false) => false;

        /// <summary>
        /// Restores properties from the prediction buffer for a given tick.
        /// Used when prediction was correct and we need to continue with predicted values after server state import.
        /// Override is generated by the source generator for classes with [NetProperty(Predicted = true)].
        /// </summary>
        internal virtual void RestoreToPredictedState(int tick) { }

        #region Explicit Interface Implementations
        // These delegate to the internal virtual methods to enable proper polymorphic dispatch
        // when called through the INetNodeBase interface. Without these, the interface's default
        // implementations would be called instead of the overridden methods in derived classes.
        
        void INetNodeBase.StorePredictedState(int tick) => StorePredictedState(tick);
        void INetNodeBase.StoreConfirmedState() => StoreConfirmedState();
        bool INetNodeBase.Reconcile(int tick, bool forceRestoreAll) => Reconcile(tick, forceRestoreAll);
        void INetNodeBase.RestoreToPredictedState(int tick) => RestoreToPredictedState(tick);
        #endregion

        /// <summary>
        /// Sets a network property by its class-local index.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        /// <param name="propIndex">The class-local property index</param>
        /// <param name="value">The new value from the network</param>
        internal virtual void SetNetPropertyByIndex(int propIndex, ref PropertyCache value) { }

        /// <summary>
        /// Invokes property change handlers for properties with NotifyOnChange = true.
        /// Override is generated by the source generator.
        /// </summary>
        internal virtual void InvokePropertyChangeHandler(int propIndex, int tick, ref PropertyCache oldVal, ref PropertyCache newVal) { }

        /// <summary>
        /// Initializes network property bindings for INetPropertyBindable properties (like NetArray).
        /// Called from _NetworkPrepare to bind callbacks for properties initialized inline.
        /// Override is generated by the source generator for classes with INetPropertyBindable properties.
        /// </summary>
        internal virtual void InitializeNetPropertyBindings() { }

        /// <summary>
        /// Writes all [NetProperty] values to a BSON document.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        internal virtual void WriteBsonProperties(BsonDocument doc, NetBsonContext context = default) { }

        /// <summary>
        /// Reads [NetProperty] values from a BSON document.
        /// Override is generated by the source generator for classes with [NetProperty] attributes.
        /// </summary>
        internal virtual void ReadBsonProperties(BsonDocument doc) { }

        /// <inheritdoc/>
        public override void _Process(double delta)
        {
            // Guard against disposed objects (can happen during node removal)
            if (!IsInstanceValid(this)) return;
            base._Process(delta);
            // Process interpolation on clients only
            // Note: Don't iterate StaticNetworkChildren here - Godot calls _Process on each node,
            // so each node handles its own interpolation. Manual iteration causes double-processing.
            if (!Network.IsServer)
            {
                ProcessInterpolation((float)delta);
            }
        }

        /// <inheritdoc/>
        public override void _PhysicsProcess(double delta) { }

        public static bool NetworkSerialize(WorldRunner currentWorld, NetPeer peer, NetNode2D obj, NetBuffer buffer, int maxBytes)
        {
            // maxBytes is ignored - NetNode2D serialization is always small (node reference)
            if (obj == null)
            {
                NetWriter.WriteUInt16(buffer, 0);
                return true;
            }
            NetId targetNetId;
            byte staticChildId = 0;
            if (obj.Network.IsNetScene())
            {
                targetNetId = obj.Network.NetId;
            }
            else
            {
                // if (Protocol.PackNode(obj.Network.NetSceneFilePath, obj.Network.NetParent.RawNode.GetPathTo(obj), out staticChildId))
                // {
                //     targetNetId = obj.Network.NetParent.NetId;
                // }
                // else
                // {
                //     throw new Exception($"Failed to pack node: {obj.Network.NetParent.NetSceneFilePath} cannot find static child {obj.Network.NetParent.RawNode.GetPathTo(obj)}: {obj.GetPath()}");
                // }
            }
            // var peerNodeId = currentWorld.GetPeerWorldState(peer).Value.WorldToPeerNodeMap[targetNetId];
            // NetWriter.WriteUInt16(buffer, peerNodeId);
            // NetWriter.WriteByte(buffer, staticChildId);
            return true;
        }

        public static void OnPeerAcknowledge(NetNode2D obj, UUID peerId)
        {
            // No-op: NetNode2D doesn't track per-peer state
        }

        public static void OnPeerDisconnected(NetNode2D obj, UUID peerId)
        {
            // No-op: NetNode2D doesn't track per-peer state
        }

        public static NetNode2D NetworkDeserialize(WorldRunner currentWorld, NetPeer peer, NetBuffer buffer, NetNode2D existing = null)
        {
            // Note: existing parameter ignored - NetNode2D deserialization is a lookup, not a create/update
            var networkID = NetReader.ReadUInt16(buffer);
            if (networkID == 0)
            {
                return null;
            }
            var staticChildId = NetReader.ReadByte(buffer);
            var node = currentWorld.GetNodeFromNetId(networkID)?.RawNode as NetNode2D;
            if (node == null)
            {
                return null;
            }
            if (staticChildId > 0)
            {
                node = node.GetNodeOrNull(Protocol.UnpackNode(node.SceneFilePath, staticChildId)) as NetNode2D;
            }
            return node;
        }

        public BsonValue BsonSerialize(NetBsonContext context)
        {
            var doc = new BsonDocument();
            if (Network.IsNetScene())
            {
                var netId = Network.NetId;
                doc["NetId"] = NetId.BsonSerialize(in netId);
            }
            else
            {
                var parentNetId = Network.NetParent.NetId;
                doc["NetId"] = NetId.BsonSerialize(in parentNetId);
                doc["StaticChildPath"] = Network.NetParent.RawNode.GetPathTo(this).ToString();
            }
            return doc;
        }

        public virtual async Task OnBsonDeserialize(NetBsonContext context, BsonDocument doc)
        {
            // Base implementation - no custom logic needed for NetNode2D
            // Derived classes should override this method
            await Task.CompletedTask;
        }

        public async Task<NetNode2D> BsonDeserialize(NetBsonContext context, byte[] bson)
        {
            return await BsonDeserialize(context, bson, this);
        }

        public static async Task<NetNode2D> BsonDeserialize(NetBsonContext context, byte[] bson, NetNode2D obj)
        {
            var data = BsonTransformer.DeserializeBsonValue<BsonDocument>(bson);
            if (data.IsBsonNull) return null;
            var doc = data.AsBsonDocument;
            var node = obj ?? new NetNode2D();

            // NetNode2D-specific deserialization logic
            node.Network._prepareNetId = NetId.BsonDeserialize(doc["NetId"]);
            if (doc.Contains("StaticChildPath"))
            {
                node.Network._prepareStaticChildPath = doc["StaticChildPath"].AsString;
            }

            // Call the virtual method for custom deserialization logic
            await node.OnBsonDeserialize(context, doc);

            return node;
        }


        public string NodePathFromNetScene()
        {
            if (Network.IsNetScene())
            {
                return GetPathTo(this);
            }

            return Network.NetParent.RawNode.GetPathTo(this);
        }
    }
}
